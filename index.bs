<pre class='metadata'>
Title: CSS Render Subtree
Shortname: css-render-subtree
Level: 1
Status: UD
Group: csswg
Work Status: exploring
URL: https://wicg.github.io/display-locking
Editor: Tab Atkins-Bittner, Google
Editor: Vladimir Levin, Google
Abstract: This spec introduces features for "display locking", allowing authors
          to provide rendering performance hints to the user-agent. The user-agent can
          use the hints to optimize rendering performance, making interactions with large
          amounts of content perform well.
</pre>

Introduction {#intro}
=====================

Render Subtree (a.k.a. Display Locking) is a CSS property designed to allow
developers and browsers to easily scale to large amount of content and provide
strong hints which allow the user-agent to delay rendering <a href=#f1>[1]</a>
work.  More concretely, the goals are:

* Avoid rendering work for content not visible to the user Support user-agent
* features and all layout algorithms (e.g. responsive design, flexbox, grid)
    for this content

Optimizing behavior and performance of the following use-cases motivate this work:

* Fast display of large HTML documents (examples: HTML one-page spec; other
    long documents)
* Deep links and searchability into pages with hidden content (example: mobile
    Wikipedia; scroll-to-text support for collapsed sections)
* Scrollers with a large amount of content, without resorting to virtualization
    (examples: Facebook and Twitter feeds, CodeMirror documents)

Motivation & Background {#motivation}
-----------------------

On the one hand, faster web page loads and interactions directly improve the
user experience of the web. On the other hand, web sites each year grow larger
and more complex than the last, in part because they support more and more use
cases, and contain more information. The most common UI pattern for the web is
scrolling, which leads to pages with a lot of non-visible (off-screen or hidden)
DOM. Since the DOM presently renders atomically, it inherently takes more and
more time to render on the same machine.

Web developers are in a good position to know whether rendering a particular
subtree that is off-screen is needed for the visual representation of their
page. Specifically, if the layout of an off-screen box and its subtree has a
visible and necessary effect on screen then such rendering is required.
Otherwise, it is not. Since web developers are in a good position to have this
information, they can provide the user-agent strong hints indicating that
rendering for a given subtree is not required in certain cases.

Traditionally, two techniques of providing this information to the user-agent
are to mark non-visible DOM as "invisible" <a href=#f2>[2]</a>, or to use
virtualization <a href=#f3>[3]</a>. Browser implementors also want to reduce
loading and rendering time of web apps. Common techniques to do so include
adding caching of rendering state <a href=#f4>[4]</a>, and avoiding rendering
work <a href=#f5>[5]</a> for content that is not visible.

These techniques can work in many cases but have drawbacks and limitations:

* <a href=#f2>[2]</a> and <a href=#f3>[3]</a> usually means that such content
    is not available to user-agent features, such as find-in-page functionality.
    Also, content that is merely placed off-screen may or may not have rendering
    cost (it depends on browser heuristics), which makes the technique
    unreliable.

* Caching intermediate rendering state is hard work, and often has performance
    limitations and cliffs that are not obvious to developers.  Similarly,
    relying on the browser to avoid rendering for content that is clipped out or
    not visible is sometimes not reliable, as it's hard for the browser to
    efficiently detect what content is not visible and does not affect visible
    content in any way.

Previously adopted web APIs, in particular the 'contain' and 'will-change' CSS
properties, add ways to specify forms of rendering isolation or isolation
hints, with the intention of them being a mechanism for the web developer to
help the browser optimize rendering for the page.

While these forms of isolation help, they do not guarantee that isolated
content does not need to be rendered at all.  Ideally there would be a way for
the developer to specify that specific parts of the DOM need not be rendered,
and pair that with a guarantee that when later rendered, it would not
invalidate more than a small amount of style, layout, or paint in the rest of
the document.

Rendering Hints: the 'render-subtree' property {#render-subtree}
==============================================

<pre class=propdef>
Name: render-subtree
Value: normal | hidden && frozen?
Initial: normal
Inherited: no
</pre>

<dl dfn-type value dfn-for=render-subtree>
    : <dfn export>normal</dfn>
    :: No effect; The element and its subtree are rendered as usual. This
          provides no extra information or hints to the user-agent.

    : <dfn export>hidden</dfn>
    :: The element has [=layout containment=] and [=style containment=] applied
         in addition to any existing containment values.

         Additionally, if the element is <dfn export>off-screen</dfn>, in the
         sense that it is not intersecting the viewport (with a reasonable
         user-agent specified margin), then element has [=size containment=]
         applied in addition to any existing containment values and the
         element's subtree is not painted or hit-tested. 

    : <dfn export>hidden frozen</dfn>
    :: The element has [=layout containment=], [=style containment=], and
         [=size containment=] applied in addition to any existing containment
         values. Furthermore, the element's subtree is not painted or hit-tested.

    : more
    :: Note that the token values are designed to be extensible. In other
         words, it is possible for new values to be added if new effects are
         desired.
</dl>

Note that in situations where 'render-subtree' values cause the element's
subtree not to be painted or hit-tested, the user-agent should avoid as much
rendering work as possible. As an example, because of the containment applied,
in most cases it should be possible to skip determining layout box sizes and
positions unless explicitly requested by script.

Examples {#examples}
========

<div class=example>
	<xmp highlight=markup>
		<style>
		.rs {
		  render-subtree: hidden;
      min-height: 50px;
		}
		</style>

		<div class=rs>
		  ... some content goes here ...
		</div>
	</xmp>

  The .rs element's 'render-subtree' value [=hidden=] lets the user-agent manage
  whether to paint and hit-test the element's subtree.  Specifically when this
  element is near the viewport, the user-agent will begin painting the element.
  When the element moves away from the viewport, it will stop being painted. In
  addition, the user-agent should skip as much of the rendering work as
  possible when the element is not painted or hit-tested.
</div>

<div class=example>
	<xmp highlight=markup>
		<style>
		.rs {
		  render-subtree: hidden frozen;
		}
		</style>

		<div class=rs>
		  ... some content goes here ...
		</div>
	</xmp>

  In this case, the element's subtree is not painted or hit-tested regardless
  of viewport intersection. This means that the only way to have this subtree
  painted is via script updating the value to remove render-subtree or change
  its value. As before, the user-agent should skip as much of the rendering in
  the subtree as possible. An additional effect of skipping rendering is that
  the layout state of the subtree can be preserved, so that removing the
  'render-subtree' property in the future will cause the subtree to be rendered
  quicker than otherwise possible.

</div>

Alternatives Considered {#alternatives}
=======================

The ''display: none'' CSS property causes content subtrees not to render.
However, there is no mechanism for user-agent features to cause these subtrees
to render.  Additionally, the cost of hiding and showing content cannot be
eliminated since ''display: none'' does not preserve the layout state of the
subtree.

''visibility: hidden'' causes subtrees to not paint, but they still need style
and layout, as the subtree takes up layout space and descendants may be
''visibility: visible''.  Second, there is no mechanism for user-agent features
to cause subtrees to render.  Note that with sufficient containment and
intersection observer, the functionality provided by 'render-subtree' may be
mimicked. Some planned extensions to this property are still not possible: for
instance, one possibility is to have the non-painted subtree still be processed
by user-agent find-in-page algorithms; this would not be possible with
visibility: hidden. Overall, 'render-subtree' property is a stronger signal
allowing the user-agent to optimize rendering.

Similar to ''visibility: hidden'', ''contain: strict'' allows the browser to
automatically detect subtrees that are definitely off-screen, and therefore
that don't need to be rendered.  However, ''contain: strict'' on its own is not
flexible enough to allow for responsive design layouts that grow elements to
fit their content.  To work around this, content could be marked as ''contain:
strict'' when off-screen and then some other value when on-screen (this is
similar to 'render-subtree').  Second, ''contain: strict'' may or may not
result in rendering work, depending on whether the browser detects the content
is actually off-screen.  Third, it does not support user-agent features in
cases when it is not actually rendered to the user in the current application
view.


Privacy & Security Considerations {#priv-sec}
=================================

tbd


Footnotes {#footnotes}
=========

<p id=f1>[1]: Meaning, the rendering part of the browser event loop.

<p id=f2>[2]: Examples:
placing ''display:none'' CSS on DOM subtrees,
or by placing content far off-screen via tricks like ''margin-left: -10000px''

<p id=f3>[3]: In this context,
virtualization means representing content outside of the DOM,
and inserting it into the DOM only when visible.
This is most commonly used for virtual or infinite scrollers.

<p id=f4>[4]: Examples:
caching the computed style of DOM elements,
the output of text / block layout,
and display list output of paint.

<p id=f5>[5]: Examples:
detecting elements that are clipped out by ancestors,
or not visible in the viewport,
and avoiding some or most rendering lifecycle phases for such content.
